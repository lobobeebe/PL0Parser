import java.util.Set;
import Utility.SetRepUtility;
import AST.*;

/**
 * The Sanitize Must Analysis.
 * For each program point, which variables MUST have been sanitized.
 */
aspect SanitizeMustAnalysis
{
    /** The kill function for sanitized variables. */
    syn Set<Var> Block.killSM(Set<Var> current);

    eq ConstDecl.killSM(Set<Var> current) = SetRepUtility.emptySet();
    eq AssignS.killSM(Set<Var> current) = SetRepUtility.singleton(getVar());
    eq LabeledExpr.killSM(Set<Var> current) = SetRepUtility.emptySet();

    /** The gen function for available expressions. */
    syn Set<Var> Block.genSM();

    eq ConstDecl.killSM(Set<Var> current) = SetRepUtility.emptySet();
    eq AssignS.killSM(Set<Var> current) = SetRepUtility.emptySet();
    eq LabeledExpr.killSM(Set<Var> current) = SetRepUtility.emptySet();

    /** Compute the entry information for the SM analysis. */
    syn Set<Var> Block.SMentry() circular [VarStar()];

    eq Block.SMentry()
    {
        Set<Var> ret;
        if (getLabelAST().equals(progInitLabel()))
        {
            ret = SetRepUtility.emptySet();
        }
        else
        {
            Set<Set<Var>> inputs = SetRepUtility.map(
                new SetRepUtility.Fun<Label, Set<Var>>()
                {
                    public Set<Var> run(Label l)
                    {
                        Block b = l.itsBlock();
                        return b.AEexit();
                    }
                }, inFlows());
            ret = SetRepUtility.intersect(inputs);
        }
        return ret;
    }

    /** Compute the exit information for the SM analysis. */
    syn Set<Var> Block.SMexit() circular [VarStar()];
    eq Block.SMexit()
    {
        Set<Var> ret = SetRepUtility.emptySet(); // start with a fresh set!
        ret.addAll(this.SMentry());
        ret.removeAll(this.killSM(ret));
        ret.addAll(this.genSM());
        return ret;
    }
}
