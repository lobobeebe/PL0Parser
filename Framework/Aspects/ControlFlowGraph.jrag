import java.util.*;
import Utility.SetRepUtility;
import Utility.FlowGraph;

/** Control Flow Graph attributes, see Section 2.1 of "Principles of Progarm Analysis"
 * by Nielsen, Nielsen, and Hankin (Springer-Verlag, 1999 and 2005).
 */
aspect ControlFlowGraph
{
    /** The initial label of an AST node. */
    syn Label S.init();
    eq AssignS.init() = getLabel();
    eq IfS.init() = getLabeledExpr().getLabel();
    eq WhileS.init() = getLabeledExpr().getLabel();
    eq BeginEndS.init() = getStatement(0).init();
    eq CallS.init() = getLabel();

    syn Label ConstDecl.init();
    eq ConstDecl.init() =  getLabel();

    /** The set of final labels of an AST node. */
    syn Set<Label> Block.finals();
    eq Block.finals() = getS().finals();

    syn Set<Label> S.finals();
    eq AssignS.finals() = SetRepUtility.singleton(getLabel());
    eq IfS.finals() = getS().finals();
    eq WhileS.finals() = SetRepUtility.singleton(getLabeledExpr().getLabel());
    eq BeginEndS.finals() = getStatement(getNumStatement() - 1).finals();
    eq CallS.finals()
    {
        Set<Label> ret = SetRepUtility.emptySet();
        /*
        for(int i = 0; i < getNumProcedure(); i++)
        {
            if(getProcedure(i).getVar().equals(getVar()))
            {
                ret = getProcedure(i).getS().finals();
            }
        }
        */
        return ret;
    }

    /** Control flow node. */
    public interface ElementaryBlock
    {
        Set<Label> inFlows();
        Set<Label> outFlows();
        Label getLabel();
    }

    Decl implements ElementaryBlock;
    AssignS implements ElementaryBlock;
    CallS implements ElementaryBlock;
    LabeledExpr implements ElementaryBlock;

    /** Set of blocks in a statement */
    syn Set<ElementaryBlock> S.blocks();
    eq AssignS.blocks() = SetRepUtility.singleton(this);
    eq IfS.blocks()
    {
    	Set<ElementaryBlock> ret = getS().blocks();
    	ret.add(getLabeledExpr());
    	return ret;
    }
    eq WhileS.blocks()
    {
    	Set<ElementaryBlock> ret = getS().blocks();
    	ret.add(getLabeledExpr());
    	return ret;
    }
    eq BeginEndS.blocks()
    {
    	Set<ElementaryBlock> ret = SetRepUtility.emptySet();
    	for(int i = 0; i < getNumStatement(); i++){
    		ret.addAll(getStatement(i).blocks());
    	}
    	return ret;
    }
    eq CallS.blocks()
    {
        Set<ElementaryBlock> ret = SetRepUtility.emptySet();
        /*
        for(int i = 0; i < getNumProcedure(); i++)
        {
            if(getProcedure(i).getVar().equals(getVar()))
            {
                ret.addAll(getProcedure(i).getConstantList());
                ret.addAll(getProcedure(i).getS().blocks());
            }
        }
        */
        return ret;
    }

    public boolean ElementaryBlock.equals(Object o){
    	if(o == null || !(o instanceof ElementaryBlock)){
    		return false;
    	}
		ElementaryBlock b = (ElementaryBlock) o;

		return toString().equals(b.toString());
    }

    public int ElementaryBlock.hashCode(){
    	return toString().hashCode();
    }

    /** Map labels to blocks */
    inh ElementaryBlock Label.itsBlock();
    eq AssignS.getLabel().itsBlock() = this;
    eq CallS.getLabel().itsBlock() = this;
    eq LabeledExpr.getLabel().itsBlock() = this;
    eq Decl.getLabel().itsBlock() = this;

    /** Flows into a block */
    inh Set<Label> Decl.inFlows();
    eq Block.getConstant(int index).inFlows()
    {
        if(index == 0)
        {
            return getS().inFlows();
        }
        else
        {
            return SetRepUtility.singleton(getConstant(index - 1).getLabel());
        }
    }
    eq Block.getVar(int index).inFlows()
    {
        if(index == 0)
        {
            if(getNumConstant() > 0)
            {
                return SetRepUtility.singleton(getConstant(getNumConstant() - 1).getLabel());
            }
            else
            {
                return getS().inFlows();
            }
        }
        else
        {
            return SetRepUtility.singleton(getVar(index - 1).getLabel());
        }
    }
    eq Block.getProc(int index).inFlows()
    {
        if(index == 0)
        {
            if(getNumVar() > 0)
            {
                return SetRepUtility.singleton(getVar(getNumVar() - 1).getLabel());
            }
            else
            {
                if(getNumConstant() > 0)
                {
                    return SetRepUtility.singleton(getConstant(getNumConstant() - 1).getLabel());
                }
                else
                {
                    return getS().inFlows();
                }
            }
        }
        else
        {
            return SetRepUtility.singleton(getVar(index - 1).getLabel());
        }
    }
	inh Set<Label> S.inFlows();
	eq Block.getS().inFlows() = SetRepUtility.emptySet();
	eq IfS.getS().inFlows() = SetRepUtility.singleton(getLabeledExpr().getLabel());
	eq WhileS.getS().inFlows() = SetRepUtility.singleton(getLabeledExpr().getLabel());
	eq BeginEndS.getStatement(int index).inFlows(){
		if(index == 0){
			return inFlows();
		} else{
			return getStatement(index-1).finals();
		}
	}

	inh Set<Label> LabeledExpr.inFlows();
	eq IfS.getLabeledExpr().inFlows() = this.inFlows();
	eq WhileS.getLabeledExpr().inFlows()
    {
		Set<Label> ins = this.inFlows();
		ins.addAll(getS().finals());
		return ins;
	}

	/** get next statement for outflows */
	inh S S.next();
	eq BeginEndS.getStatement(int index).next()
    {
		if(index == getNumStatement() - 1)
        {
			return next();
		}
		else
        {
			return getStatement(index+1);
		}
	}

	eq Block.getS().next() = null;
	eq IfS.getS().next() = next();
	eq WhileS.getS().next() = this;

	/** Flows out of a block */
    inh Set<Label> Decl.outFlows();
    eq Block.getConstant(int index).outFlows()
    {
        if(index == getNumConstant() - 1)
        {
            if(getNumVar() > 0)
            {
                return SetRepUtility.singleton(getVar(0));
            }
            else
            {
                if(getNumProc() > 0)
                {
                    return SetRepUtility.singleton(getProc(0));
                }
                else
                {
                    return SetRepUtility.singleton(getS().init());
                }
            }
        }
        else
        {
            return SetRepUtility.singleton(getConstant(index + 1).getLabel());
        }
    }
    eq Block.getVar(int index).outFlows()
    {
        if(index == getNumVar() - 1)
        {
            if(getNumProc() > 0)
            {
                return SetRepUtility.singleton(getProc(0).getLabel());
            }
            else
            {
                return SetRepUtility.singleton(getS().init());
            }
        }
        else
        {
            return SetRepUtility.singleton(getVar(index + 1).getLabel());
        }
    }
    eq Block.getProc(int index).outFlows()
    {
        if(index == getNumProc() - 1)
        {
            return SetRepUtility.singleton(getS().init());
        }
        else
        {
            return SetRepUtility.singleton(getVar(index + 1).getLabel());
        }
    }
	inh Set<Label> S.outFlows();
	eq Block.getS().outFlows() = SetRepUtility.emptySet();
	eq IfS.getS().outFlows()
    {
		if(next() == null)
        {
			return SetRepUtility.emptySet();
		}
		else
        {
			return SetRepUtility.singleton(next().init());
		}
	}
	eq WhileS.getS().outFlows()
    {
		return SetRepUtility.singleton(getLabeledExpr().getLabel());
	}
	eq BeginEndS.getStatement(int index).outFlows()
    {
		if(index == getNumStatement() - 1)
        {
			return outFlows();
		}
		else
        {
			return SetRepUtility.singleton(getStatement(index + 1).init());
		}
	}

	inh Set<Label> LabeledExpr.outFlows();
	eq IfS.getLabeledExpr().outFlows()
    {
		return SetRepUtility.singleton(getS().init());
	}
	eq WhileS.getLabeledExpr().outFlows()
    {
		Set<Label> ret = SetRepUtility.singleton(getS().init());
		if(next() != null)
        {
			ret.add(next().init());
		}

		return ret;
	}
}
